---
title: Swift里Data的压缩zip、unzip, AES、MD5加解密
author: 独孤流
date: 2023-06-30 23:12:00 +0800
categories: [加解密]
tags: [AES, MD5]      # TAG names should always be lowercase
---
参考：
- [NSData+zlib](https://github.com%2Fgoogle%2FGoogleUtilities%2Ftree%2Fmain%2FGoogleUtilities%2FNSData%252Bzlib)
- [CryptoSwift](https://github.com%2Fkrzyzanowskim%2FCryptoSwift)
- [SwiftyRSA](https://github.com%2FTakeScoop%2FSwiftyRSA)
- [swift 5.0 RSA+AES加密插件CryptoSwift以及SwiftyRSA的使用](https://blog.csdn.net%2Fchechengxue%2Farticle%2Fdetails%2F109308418)


使用`NSData+zlib`进行zip、unzip操作
使用`CryptoSwift`进行md5、AES、SHA
使用`SwiftyRSA`进行RSA
CommonCrypto

使用`CryptoSwift`的方式
```
import Foundation
import CryptoSwift

static func AESEncryptOld(key: String?, data: Data?) -> Data? {
        return AESCryptOld(isEncode: true, key: key?.data(using: .utf8), data: data)
    }
    
    static func AESDecryptOld(key: String?, data: Data?) -> Data? {
        return AESCryptOld(isEncode: false, key: key?.data(using: .utf8), data: data)
    }
    static func AESCryptOld(isEncode: Bool, key: Data?, data: Data?) -> Data? {
        guard let data = data, data.count > 0 else { return nil }
        guard let key = key, key.count > 0 else { return nil }
        do {
            if isEncode == false {
                // 解密
                let deBytes = try AES(key: key.bytes, blockMode: ECB(), padding: .pkcs5).decrypt(data.sp_bytes)
                return Data(deBytes)
            } else {
                // 加密
                let enBytes = try AES(key: key.bytes, blockMode: ECB(), padding: .pkcs5).encrypt(data.sp_bytes)
                return Data(enBytes)
            }
        } catch let error {
            print("decodeAES--data: \(error)")
        }
        return nil
    }
```

使用系统库`CommonCrypto`的方式
```
import Foundation
import CommonCrypto

static func AESEncrypt(key: String?, data: Data?) -> Data? {
    return AESCrypt(op: CCOperation(kCCEncrypt), key: key?.data(using: .utf8), data: data)
}

static func AESDecrypt(key: String?, data: Data?) -> Data? {
    return AESCrypt(op: CCOperation(kCCDecrypt), key: key?.data(using: .utf8), data: data)
}

static func AESCrypt(op: CCOperation, key: Data?, data: Data?) -> Data? {
    guard let data = data, data.count > 0 else { return nil }
    guard let key = key, key.count > 0 else { return nil }
    let keyLength = kCCKeySizeAES128
    let cryptLength = data.count + kCCBlockSizeAES128
    var cryptData = Data(count: cryptLength)
    var numBytesEncrypted: Int = 0
    
    let cryptStatus = cryptData.withUnsafeMutableBytes { cryptBytes in
        data.withUnsafeBytes { dataBytes in
            key.withUnsafeBytes { keyBytes in
                CCCrypt(op,
                        CCAlgorithm(kCCAlgorithmAES),
                        CCOptions(kCCOptionECBMode + kCCOptionPKCS7Padding),
                        keyBytes.baseAddress, keyLength,
                        nil,
                        dataBytes.baseAddress, data.count,
                        cryptBytes.baseAddress, cryptLength,
                        &numBytesEncrypted)
            }
        }
    }
    
    if cryptStatus == kCCSuccess {
        cryptData.removeSubrange(numBytesEncrypted..<cryptData.count)
        return cryptData
    }
    return nil
}
```

zip的压缩与解压缩
```
import Foundation
import GoogleUtilities

extension Data {
    var gzip: Data? {
        do {
            let result =  try NSData.gul_data(byGzippingData: self)
            return result
        } catch let error {
            print(error)
        }
        return nil
    }
    var gUnZip: Data? {
        do {
            let result =  try NSData.gul_data(byInflatingGzippedData: self)
            return result
        } catch let error {
            print(error)
        }
        return nil
    }
}
```

----
其他测试代码
```

import Foundation
import GoogleUtilities
import CryptoSwift
import SwiftyRSA

class DataCryptTool {
    static func test() {
        let data = "123456".data(using: .utf8)
        let data1 = data?.gzip
        let data2 = data1?.gUnZip
        let data3 = data?.AESCrypt(key: "1234567890123456", padding: .pkcs5Padding, isEncode: true)
        let data4 = data3?.AESCrypt(key: "1234567890123456", padding: .pkcs5Padding, isEncode: false)
        print(data?.bString ?? "")
        print(data1?.bString ?? "")
        print(data2?.bString ?? "")
        print(data3?.bString ?? "")
        print(data4?.bString ?? "")
    }
}
enum AESPaddingType {
    case pkcs7Padding
    case pkcs5Padding
    
    var aesVal: CryptoSwift.Padding {
        switch self {
        case .pkcs5Padding:
            return .pkcs5
        case .pkcs7Padding:
            return .pkcs7
        }
    }
}
extension Data {
    var gzip: Data? {
        do {
            let result =  try NSData.gul_data(byGzippingData: self)
            return result
        } catch let error {
            print(error)
        }
        return nil
    }
    var gUnZip: Data? {
        do {
            let result =  try NSData.gul_data(byInflatingGzippedData: self)
            return result
        } catch let error {
            print(error)
        }
        return nil
    }
    // AES/ECB/Padding7
    // AES/ECB/Padding5
    func AESCrypt(key: String, padding: AESPaddingType, isEncode: Bool) -> Data? {
        do {
            let setting = try AES(key: key.bytes, blockMode: ECB(), padding: padding.aesVal)
            let result = try isEncode ? setting.encrypt(self.bytes) : setting.decrypt(self.bytes)
            return result.data
        } catch let error {
            print(error)
        }
        return nil
    }
    public typealias RSAPadding = SecPadding
    static func RSACrypt(val: String, key: String, padding: RSAPadding, isEncode: Bool) -> String? {
        guard let keyData = key.data(using: .utf8) else {
            return nil
        }
        do {
            if isEncode {
                // 公钥加密
                let publicKey = try PublicKey(base64Encoded: key)
                let message = try ClearMessage(string: val, using: .utf8)
                let data = try message.encrypted(with: publicKey, padding: padding)
                return data.base64String
            } else {
                // 私钥解密
                let privateKey = try PrivateKey(base64Encoded: key)
                let message = try EncryptedMessage(base64Encoded: val)
                let data = try message.decrypted(with: privateKey, padding: padding)
                return data.base64String
            }
        } catch let error {
            print(error)
        }
        return nil
    }
}


```