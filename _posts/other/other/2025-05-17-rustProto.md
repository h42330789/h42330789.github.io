---
title: rust编译proto文件
author: 独孤流
date: 2025-05-17 10:14:00 +0800
categories: [other, 其他]
tags: [iOS]     # TAG names should always be lowercase
---

> ### 前言
> 由于使用`rust`改写IM逻辑，但是之前大量的数据结构是使用到了`protobuf`，于是需要将原始的`xxx.proto`文件改写成`xxx.rs`

### 一、所有的proto生成一个文件

我的demo的整体结构
```
.
├── greeting
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── build.rs
│   ├── src
└── protos
    ├── common.proto
    └── user.proto
```

原始的proto文件
`/xxx/xx/testRust/protos/common.proto`
```
syntax = "proto3";
option java_package="com.im.domain.pb";
option java_outer_classname="CommonProto";
// protoc.exe  -I=. --java_out=../src common.proto

// 客户端详情
message ClientInfo {
    string     sessionId      = 1; // session
    int32      appVer         = 2; // 应用版本号
    int32      channelId    = 3; // 包ID
    Platform   plat           = 4; // 登陆平台
    int32      language       = 5; // 系统语言
    string     deviceId         = 6; // 设备号
    string     deviceName       = 7; // 设备名称
}

// 平台
enum Platform {
    app_android     = 0; // 安卓手机端
    app_iphone      = 1; // 苹果手机端
    app_hormary     = 2; // 鸿蒙手机端
    pc_win          = 3; // windows的pc端
    pc_mac          = 4; // Mac的pc端
    pc_linux        = 5; // Mac的pc端
    h5_phone        = 6; // Mac的pc端
    h5_pc           = 7; // Mac的pc端
    
}
```
`/xxx/xx/testRust/protos/user.proto`
```
syntax = "proto3";
option java_package="com.im.domain.pb";
option java_outer_classname="UserProto";

// 添加这行导入
import "common.proto";

message CreateArchiveReq {
    ClientInfo clientInfo = 1;  // 使用全限定名
}
```

在rust项目的目录下配置工具可以编译proto文件
`/xxx/xx/testRust/greeting/Cargo.toml`
```
[package]
name = "xxxx"
version = "0.1.0"
edition = "2024"

[dependencies]

# Protobuf 引入prost生成proto文件
prost = "0.12"
prost-types = "0.12"

[build-dependencies]
prost-build = "0.12"
```

在rust项目的目录下配置编译文件
`/xxx/xx/testRust/greeting/build.rs`
```
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {

 
    let mut config = prost_build::Config::new();
    // 配置proto生成后的文件夹
    config.out_dir("src/generated");
    // 没有package xxx; 则会全部生成到 _.rs里去
    config.compile_protos(&[
        "../protos/user.proto",
    ], &["../protos"])?;

    Ok(())
}
```

执行代码
```
cd /xxx/xx/testRust/greeting
cargo clean
cargo build
```
生成的文件# `/xxx/xx/testRust/greeting/src/generated/_.rs`
最终生成的文件如下
```
.
├── greeting
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── build.rs
│   ├── src
│   │   ├── generated
│   │   │   └── _.rs
│   │   └── main.rs
│   └── temp_protos
└── protos
    ├── common.proto
    └── user.proto
```

`/xxx/xx/testRust/greeting/src/generated/_.rs`的内容如下
```
// This file is @generated by prost-build.
/// 客户端详情
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientInfo {
    /// session
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// 应用版本号
    #[prost(int32, tag = "2")]
    pub app_ver: i32,
    /// 包ID
    #[prost(int32, tag = "3")]
    pub channel_id: i32,
    /// 登陆平台
    #[prost(enumeration = "Platform", tag = "4")]
    pub plat: i32,
    /// 系统语言
    #[prost(int32, tag = "5")]
    pub language: i32,
    /// 设备号
    #[prost(string, tag = "6")]
    pub device_id: ::prost::alloc::string::String,
    /// 设备名称
    #[prost(string, tag = "7")]
    pub device_name: ::prost::alloc::string::String,
}
/// 平台
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Platform {
    /// 安卓手机端
    AppAndroid = 0,
    /// 苹果手机端
    AppIphone = 1,
    /// 鸿蒙手机端
    AppHormary = 2,
    /// windows的pc端
    PcWin = 3,
    /// Mac的pc端
    PcMac = 4,
    /// Mac的pc端
    PcLinux = 5,
    /// Mac的pc端
    H5Phone = 6,
    /// Mac的pc端
    H5Pc = 7,
}
impl Platform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Platform::AppAndroid => "app_android",
            Platform::AppIphone => "app_iphone",
            Platform::AppHormary => "app_hormary",
            Platform::PcWin => "pc_win",
            Platform::PcMac => "pc_mac",
            Platform::PcLinux => "pc_linux",
            Platform::H5Phone => "h5_phone",
            Platform::H5Pc => "h5_pc",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "app_android" => Some(Self::AppAndroid),
            "app_iphone" => Some(Self::AppIphone),
            "app_hormary" => Some(Self::AppHormary),
            "pc_win" => Some(Self::PcWin),
            "pc_mac" => Some(Self::PcMac),
            "pc_linux" => Some(Self::PcLinux),
            "h5_phone" => Some(Self::H5Phone),
            "h5_pc" => Some(Self::H5Pc),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArchiveReq {
    /// 使用全限定名
    #[prost(message, optional, tag = "1")]
    pub client_info: ::core::option::Option<ClientInfo>,
}

```
----
### 二、不同的proto生成不同的文件
1、这个只需要修改原始的proto文件，要保证每个proto文件都要有`package xxx;`
2、引入的其他文件必须要使用其他文件的package来一如使用

修改如下
我的demo的整体结构
```
.
├── greeting
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── build.rs
│   ├── src
└── protos
    ├── common2.proto
    └── user2.proto
```

原始的proto文件
`/xxx/xx/testRust/protos/common2.proto`
```
syntax = "proto3";
package common2; // 要想生成独立的文件必须这样有package
option java_package="com.im.domain.pb";
option java_outer_classname="CommonProto";
// protoc.exe  -I=. --java_out=../src common.proto

// 客户端详情
message ClientInfo {
    string     sessionId      = 1; // session
    int32      appVer         = 2; // 应用版本号
    int32      channelId    = 3; // 包ID
    Platform   plat           = 4; // 登陆平台
    int32      language       = 5; // 系统语言
    string     deviceId         = 6; // 设备号
    string     deviceName       = 7; // 设备名称
}

// 平台
enum Platform {
    app_android     = 0; // 安卓手机端
    app_iphone      = 1; // 苹果手机端
    app_hormary     = 2; // 鸿蒙手机端
    pc_win          = 3; // windows的pc端
    pc_mac          = 4; // Mac的pc端
    pc_linux        = 5; // Mac的pc端
    h5_phone        = 6; // Mac的pc端
    h5_pc           = 7; // Mac的pc端
    
}
```
`/xxx/xx/testRust/protos/user2.proto`
```
syntax = "proto3";
package user2; // 要想生成独立的文件必须这样有package
option java_package="com.im.domain.pb";
option java_outer_classname="UserProto";

// 添加这行导入
import "common2.proto";

message CreateArchiveReq {
    common2.ClientInfo clientInfo = 1;  // 使用全限定名 由于ClientInfo是common2里一如的，这里必须要带有包名
}
```
最终生成的文件如下
```
.
├── greeting
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── build.rs
│   ├── src
│   │   ├── generated
│   │   │   ├── common2.rs
│   │   │   └── user2.rs
│   │   └── main.rs
│   └── temp_protos
└── protos
    ├── common2.proto
    └── user2.proto
```

----
### 三、便利文件夹下的所有proto全自动生成
build.rs
```
use std::path::{Path, PathBuf};
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let proto_dir = PathBuf::from("../protos"); // 简化为相对路径
    let out_dir = PathBuf::from("./src/generated");
    
    // 收集所有非web.proto文件
    let mut proto_files = Vec::new();
    for entry in fs::read_dir(&proto_dir)? {
        let entry = entry?;
        let path = entry.path();
        let file_name = path.to_string_lossy(); // 转为字符串
        
        // 简单粗暴的判断：是.proto文件且不包含"aa.proto"
        if file_name.ends_with(".proto") && !file_name.contains("aa.proto") {
            proto_files.push(path);
        }
    }

    // 编译
    prost_build::Config::new()
        .out_dir(out_dir)
        .compile_protos(&proto_files, &[proto_dir])?;

    Ok(())
}
```

### 4、即使在不同文件里定义的枚举的内部名称，只要相同就会编译失败

### 5、将
