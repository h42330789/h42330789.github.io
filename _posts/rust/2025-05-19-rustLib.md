---
title: åœ¨åŸç”Ÿswift/java/fluuteré‡Œè°ƒç”¨rustçš„åº“
author: ç‹¬å­¤æµ
date: 2025-05-19 10:14:00 +0800
categories: [rust]
tags: [iOS]     # TAG names should always be lowercase
---


rusté¡¹ç›®demo
```
use std::ffi::{c_char, CString, CStr};
use std::thread;

use super::services;

/// 1. æ— è¿”å›å€¼æ¥å£
#[no_mangle]
pub extern "C" fn do_something() {
    println!("api.rs: do_something");
    services::do_internal_work();
}

/// 2. åŒæ­¥è¿”å›å€¼æ¥å£
#[no_mangle]
pub extern "C" fn get_sync_result() -> *mut c_char {
    println!("api.rs: get_sync_result");
    let result = services::get_result_string();
    result.into_raw()
}

/// å›è°ƒå‡½æ•°ç±»å‹ï¼ˆç”¨äºå¼‚æ­¥è°ƒç”¨ï¼‰
type CallbackFn = extern "C" fn(result: *const c_char);

/// 3. å¼‚æ­¥æ‰§è¡Œä»»åŠ¡ + å›è°ƒ
#[no_mangle]
pub extern "C" fn run_async_task(callback: CallbackFn) {
    println!("api.rs: run_async_task");
    thread::spawn(move || {
        println!("api.rs: Running async task...");
        let result = services::simulate_async_result();
        callback(result.as_ptr());
        std::mem::forget(result); // é¿å…é‡Šæ”¾
    });
}

/// 3.1 å¸¦ä¸Šä¸‹æ–‡å‚æ•°çš„å¼‚æ­¥ä»»åŠ¡ + å›è°ƒ
#[no_mangle]
pub unsafe extern "C" fn run_async_task_with_name(name: *const c_char, callback: CallbackFn) {
    println!("api.rs: run_async_task_with_name");
    assert!(!name.is_null());
    let name_cstr = CStr::from_ptr(name);
    let name_str = name_cstr.to_string_lossy().to_string();

    std::thread::spawn(move || {
        println!("api.rs: Running async task for '{}'", name_str);
        let result = services::simulate_async_result();
        let full_result = CString::new(format!("{} -> {}", name_str, result.to_str().unwrap())).unwrap();
        callback(full_result.as_ptr());
        std::mem::forget(full_result);
    });
}



/// 4. Rust ä¸»åŠ¨è§¦å‘å›è°ƒï¼ˆæ¨¡æ‹Ÿ push æœºåˆ¶ï¼‰
static mut GLOBAL_CALLBACK: Option<CallbackFn> = None;

/// æ³¨å†Œå›è°ƒ
#[no_mangle]
pub extern "C" fn register_callback(callback: CallbackFn) {
    unsafe {
        GLOBAL_CALLBACK = Some(callback);
    }
}

/// ä¸»åŠ¨è§¦å‘å›è°ƒ
#[no_mangle]
pub extern "C" fn trigger_callback_from_rust() {
    let msg = CString::new("Triggered from Rust (push event)").unwrap();
    unsafe {
        if let Some(cb) = GLOBAL_CALLBACK {
            cb(msg.as_ptr());
        }
        std::mem::forget(msg);
    }
}
```

é…ç½®æ–‡ä»¶`Cargo.toml`
```
[package]
name = "my_rust_lib"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }


[lib]
name = "my_rust_lib"
crate-type = ["staticlib", "cdylib"]
```


é…ç½®è‡ªåŠ¨ç”Ÿæˆ.hæ–‡ä»¶ `cbindgen.toml`
```
language = "C"
include_version = true
pragma_once = true

[export]
include = ["do_something", "get_sync_result", "run_async_task", "run_async_task_with_name", "register_callback", "trigger_callback_from_rust"]

```
å•ç‹¬ç”Ÿæˆå¤´æ–‡ä»¶
ç”Ÿæˆçš„æ–¹æ³•å¿…é¡»è¦æœ‰å…³é”®å­—
`#[no_mangle]`
`pub extern "C" fun`
```

# --crate	ä½ çš„ crate åï¼ˆå¯ä»¥æ˜¯å½“å‰ç›®å½•çš„ Cargo.toml ä¸­ [package] nameï¼‰
# --output	æŒ‡å®š .h æ–‡ä»¶è¾“å‡ºè·¯å¾„
# --config	å¯é€‰ï¼šæŒ‡å®šé…ç½®æ–‡ä»¶ï¼ˆæ¨èï¼‰
cbindgen --config cbindgen.toml --crate xxx --output include/my_rust_lib_bridge.h

```

è‡ªåŠ¨ç”Ÿæˆå¤´æ–‡ä»¶åŠxcframeworkçš„è„šæœ¬`build_all.sh`
```
#!/bin/bash
set -e

CRATE_NAME="my_rust_lib"
IOS_OUTPUT_DIR="output/ios"
HEADER_OUTPUT="output/include/${CRATE_NAME}.h"

# æ¸…ç†æ—§äº§ç‰©
rm -rf output
mkdir -p "$IOS_OUTPUT_DIR" "$(dirname "$HEADER_OUTPUT")"

echo "ğŸ”¨ Step 1: ç¼–è¯‘ iOS çœŸæœº arm64"
cargo build --release --target aarch64-apple-ios

echo "ğŸ”¨ Step 2: ç¼–è¯‘ iOS æ¨¡æ‹Ÿå™¨ arm64"
cargo build --release --target aarch64-apple-ios-sim

echo "ğŸ“„ Step 3: ç”Ÿæˆ C å¤´æ–‡ä»¶ (.h)"
cbindgen --crate $CRATE_NAME --output $HEADER_OUTPUT

echo "ğŸ§© Step 4: åˆ›å»º .xcframework (çœŸæœºå’Œæ¨¡æ‹Ÿå™¨éƒ½æ˜¯ arm64)"

xcodebuild -create-xcframework \
  -library target/aarch64-apple-ios/release/lib${CRATE_NAME}.a \
  -headers output/include \
  -library target/aarch64-apple-ios-sim/release/lib${CRATE_NAME}.a \
  -headers output/include \
  -output ${IOS_OUTPUT_DIR}/${CRATE_NAME}.xcframework

echo "âœ… å®Œæˆï¼Œç”Ÿæˆè·¯å¾„ï¼š${IOS_OUTPUT_DIR}/${CRATE_NAME}.xcframework"

tree output


# å‰æï¼Œéœ€è¦å®‰è£…å’Œé…ç½®
# brew install cbindgen lipo
# rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim
# rustup target add aarch64-linux-android armv7-linux-androideabi x86_64-linux-android
```

----

ä¸€ã€iOSé‡Œswifté¡¹ç›®æ¥å…¥æµ‹è¯•
1ã€åˆ›å»ºä¸€ä¸ªswifté¡¹ç›®
2ã€å°†ç”Ÿæˆçš„xcframeworkæ‹–åˆ°é¡¹ç›®é‡Œ
3ã€TARGETS -> Frameworks, Libraries, and Embeded Content -> ç¡®ä¿æœ‰ï¼Œ ä¸”Embed & sign
4ã€é…ç½®æ¡¥æ¥æ–‡ä»¶xxx.h
```
#include "my_rust_lib.h"  // è¿™é‡Œæ˜¯ä½ ç”Ÿæˆçš„ .h æ–‡ä»¶åï¼Œéœ€æ‹·è´åˆ°é¡¹ç›®é‡Œæˆ–æŒ‡å®šè·¯å¾„
```

5ã€é…ç½® Objective-C Bridging Headeré‡Œé…ç½®ç¡®å®šçš„æ¡¥æ¥æ–‡ä»¶

6ã€åœ¨Appdelegate.swifté‡Œè°ƒç”¨
```
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        // åŒæ­¥è°ƒç”¨æ— è¿”å›å€¼
        do_something()
        // åŒæ­¥è°ƒç”¨ï¼ŒåŒæ­¥è¿”å›å€¼
        print("swift: get_sync_result")
        if let cStringPtr = get_sync_result() {
            let str = String(cString: cStringPtr)
            print("swift: \(str)")
        }
        // è°ƒç”¨ï¼Œå¼‚æ­¥è¿”å›
        run_async_task_with_name("aaa".allocateUnsafeCString(), { cStringPtr in
            if let cStringPtr = cStringPtr {
                let str = String(cString: cStringPtr)
                print("swift-run_async_task_with_name: \(str)")
            }
        })
        // æ³¨å†Œè°ƒç”¨
        register_callback({ cStringPtr in
            if let cStringPtr = cStringPtr {
                let str = String(cString: cStringPtr)
                print("swift-register_callback: \(str)")
            }
        })
        trigger_callback_from_rust()
        
        return true
    }
```
![image](/assets/img/rust/swift_rust.png)
----
åœ¨flutteré‡Œæ‰‹åŠ¨è°ƒç”¨æ¥å…¥rustçš„åº“
æ–¹å¼1ã€
1ã€æ‰“å¼€`Runner.xcworkspace`é¡¹ç›®ï¼Œå°†æ‰“åŒ…å‡ºæ¥çš„`xxx.xcframework`åŠ å…¥åˆ°é¡¹ç›®é‡Œ

2ã€é…ç½®ã€TARGETS -> Frameworks, Libraries, and Embeded Content -> ç¡®ä¿æœ‰ï¼Œ ä¸”Embed & sign

3ã€åœ¨`Runner-Bridging-Header.h`é‡ŒåŠ å…¥åº“é‡Œçš„å¤´æ–‡ä»¶`#include "my_rust_lib.h" `

4ã€åœ¨Appdelegate.swifté‡Œè°ƒç”¨
```
override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
      // è°ƒç”¨ä¸‹åº“é‡Œçš„æ–¹æ³•ï¼Œè¿™æ ·åœ¨flutterè°ƒç”¨æ—¶æ‰èƒ½æ‰¾åˆ°åº“
      // ä¸ç„¶ä¼šæŠ¥é”™ï¼š
     // Invalid arguments(s): Failed to lookup symbol 'get_sync_result': dlsym(RTLD_DEFAULT, get_sync_result):sysmbol not found
      do_something()
      
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
```

5ã€åœ¨flutteré‡Œè°ƒç”¨
```
import 'dart:ffi';
import 'package:ffi/ffi.dart';
import 'package:flutter/material.dart';

typedef GetSyncResultNative = Pointer<Utf8> Function();
typedef GetSyncResultDart = Pointer<Utf8> Function();

final dylib = DynamicLibrary.process();

final GetSyncResultDart getSyncResult = dylib
    .lookupFunction<GetSyncResultNative, GetSyncResultDart>('get_sync_result');

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String rustResult = "Waiting for Rust...";

  @override
  void initState() {
    super.initState();
    _callRust();
  }

  void _callRust() {
    final ptr = getSyncResult();
    final result = ptr.toDartString();
    // ä¸è°ƒç”¨ freeRustStringï¼Œé¿å…æ‰¾ä¸åˆ°ç¬¦å·
    setState(() {
      rustResult = result;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: const Text('Rust FFI Demo')),
        body: Center(
          child: Text(rustResult, style: const TextStyle(fontSize: 24)),
        ),
      ),
    );
  }
}

```
![image](/assets/img/rust/flutter_rust_manul1.png)
![image](/assets/img/rust/flutter_rust_success.png)
é—®é¢˜ï¼š`Invalid arguments(s): Failed to lookup symbol 'get_sync_result': dlsym(RTLD_DEFAULT, get_sync_result):sysmbol not found`

å¿…é¡»è¦`Runner`é¡¹ç›®åŸç”Ÿä»£ç è°ƒç”¨ä¸€æ¬¡ï¼Œå¦åˆ™è¢«è‡ªåŠ¨ä¼˜åŒ–äº†

flutteræ–¹æ¡ˆäºŒï¼š
ä¿è¯ç¬¦å·ä¸ä¼šè¢«ä¼˜åŒ–æ‰
Xcode å’Œé“¾æ¥å™¨æœ‰æ—¶ä¼šå‰”é™¤æœªä½¿ç”¨ç¬¦å·ï¼Œå¯¼è‡´è¿è¡Œæ—¶æ‰¾ä¸åˆ°ã€‚

å¸¸ç”¨æŠ€å·§ï¼š

åœ¨ AppDelegate çš„æŸä¸ªåœ°æ–¹è°ƒç”¨ä¸€æ¬¡ Rust å‡½æ•°ï¼ˆå“ªæ€•æ˜¯ç©ºè°ƒç”¨ï¼‰ï¼Œä¿è¯é“¾æ¥å™¨ä¿ç•™ç¬¦å·

æˆ–è€…ç”¨ -force_load é“¾æ¥å‚æ•°å¼ºåˆ¶åŠ è½½é™æ€åº“å…¨éƒ¨ç¬¦å·
```
# åœ¨ Xcode çš„ Build Settings -> Other Linker Flags æ·»åŠ 
# é’ˆå¯¹ä¸åŒæ¶æ„ï¼Œä½ å¯èƒ½éœ€è¦æ·»åŠ å¤šä¸ª -force_loadï¼Œæ¯”å¦‚ï¼š

-force_load
${SRCROOT}/Frameworks/my_rust_lib.xcframework/ios-arm64-simulator/libmy_rust_lib.a
```
![image](/assets/img/rust/flutter_runner_forceload.png)


----
æ‰‹åŠ¨ä½¿ç”¨`flutter_rust_bridge_codegen`
1ã€åœ¨rusté¡¹ç›®çš„`Cargo.toml`é‡Œæ–°å¢é…ç½®`flutter_rust_bridge`
```
[package]
name = "my_rust_lib"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
flutter_rust_bridge = "=2.10.0"


[lib]
name = "my_rust_lib"
crate-type = ["staticlib", "cdylib"]

```

ä½¿ç”¨è„šæ­¥ç”Ÿæˆå¯¹åº”çš„dartæ–‡ä»¶
```
flutter_rust_bridge_codegen generate \
  --rust-input crate::api \
  --rust-root ../../my_rust_lib \
  --dart-output lib/rust \
  --c-output ../../my_rust_lib/src/bridge_generated.rs
```

ç”ŸæˆFrameworkæ–‡ä»¶


é¡¹ç›®é‡Œä½¿ç”¨`main.dart`
```
import 'package:flutter/material.dart';
import 'rust/frb_generated.dart';
import 'rust/api/app_api.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // åˆå§‹åŒ– RustLib
  await RustLib.init();
  
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  String _result = '';

 
  // è°ƒç”¨åŒæ­¥è¿”å›å€¼æ¥å£
  Future<void> _callGetSyncResult() async {
    final result = await getSyncResult();
    setState(() {
      _result = 'åŒæ­¥ç»“æœ: $result';
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Rust API è°ƒç”¨ç¤ºä¾‹'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              onPressed: _callGetSyncResult,
              child: const Text('è°ƒç”¨ getSyncResult'),
            )
          ],
        ),
      ),
    );
  }
}

```